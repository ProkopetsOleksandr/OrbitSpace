---
phase: 01-foundation-authentication
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - dotnet-web-api/OrbitSpace/Controllers/AuthenticationController.cs
  - dotnet-web-api/OrbitSpace/Identity/ApplicationUserProvider.cs
  - dotnet-web-api/OrbitSpace/Startup/DependencyInjection.cs
autonomous: true

must_haves:
  truths:
    - "Auth controller exposes register, login, refresh, revoke, revoke-all endpoints via OpenAPI"
    - "Login endpoint accepts JSON body (not query params)"
    - "ApplicationUserProvider reads real userId from JWT claims (no hardcoded temp ID)"
    - "Auth endpoints return proper HTTP status codes (200, 400, 401)"
  artifacts:
    - path: "dotnet-web-api/OrbitSpace/Controllers/AuthenticationController.cs"
      provides: "REST endpoints for register, login, refresh, revoke, revoke-all"
      exports: ["Register", "Login", "Refresh", "Revoke", "RevokeAll"]
    - path: "dotnet-web-api/OrbitSpace/Identity/ApplicationUserProvider.cs"
      provides: "Real JWT claim extraction for userId"
      contains: "GetValueFromClaim"
  key_links:
    - from: "OrbitSpace/Controllers/AuthenticationController.cs"
      to: "OrbitSpace.Application/Services/Interfaces/IAuthenticationService.cs"
      via: "dependency injection"
      pattern: "IAuthenticationService"
    - from: "OrbitSpace/Identity/ApplicationUserProvider.cs"
      to: "JWT claims"
      via: "ClaimTypes.NameIdentifier"
      pattern: "ClaimTypes\\.NameIdentifier"
---

<objective>
Update the authentication controller to expose all auth endpoints via OpenAPI (remove IgnoreApi attribute), use proper DTOs for login, add refresh/revoke endpoints, and fix the ApplicationUserProvider to read real user IDs from JWT claims instead of using a hardcoded temp ID.

Purpose: The controller is the HTTP layer that the Next.js frontend will call. It must be visible in OpenAPI for type generation and accept proper request bodies. The ApplicationUserProvider fix is critical — without it, all authenticated requests return data for the wrong user.
Output: Working REST API endpoints testable via Scalar/Postman.
</objective>

<execution_context>
@C:/Users/Александр/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Александр/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/01-foundation-authentication/01-RESEARCH.md
@.planning/phases/01-foundation-authentication/01-01-SUMMARY.md

Key existing files to read:
@dotnet-web-api/OrbitSpace/Controllers/AuthenticationController.cs
@dotnet-web-api/OrbitSpace/Identity/ApplicationUserProvider.cs
@dotnet-web-api/OrbitSpace/Identity/IApplicationUserProvider.cs
@dotnet-web-api/OrbitSpace/Controllers/ApiControllerBase.cs
@dotnet-web-api/OrbitSpace/Startup/DependencyInjection.cs
@dotnet-web-api/OrbitSpace/Controllers/GoalsController.cs (for reference on controller patterns)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Update AuthenticationController with all endpoints and proper OpenAPI docs</name>
  <files>
    dotnet-web-api/OrbitSpace/Controllers/AuthenticationController.cs
  </files>
  <action>
    **1. Remove `[ApiExplorerSettings(IgnoreApi = true)]`** — this hides the controller from OpenAPI/Swagger. All auth endpoints must be visible for frontend type generation.

    **2. Update `Register` endpoint:**
    - Keep `[HttpPost("register")]`, `[AllowAnonymous]`
    - Accept `[FromBody] RegisterRequestDto request` (already does this)
    - Add `[ProducesResponseType(StatusCodes.Status200OK)]` and `[ProducesResponseType(typeof(ProblemDetails), StatusCodes.Status400BadRequest)]`
    - On error, return `Problem(statusCode: StatusCodes.Status400BadRequest, detail: result.Error.ErrorMessage)` instead of bare `Problem()`

    **3. Update `Login` endpoint:**
    - Change from `Login(string email, string password)` to `Login([FromBody] LoginRequestDto request)`
    - Call `authenticationService.LoginAsync(request)` instead of passing separate params
    - Add `[ProducesResponseType(typeof(LoginResponseDto), StatusCodes.Status200OK)]` and `[ProducesResponseType(typeof(ProblemDetails), StatusCodes.Status401Unauthorized)]`
    - On error, return `Unauthorized()` with problem details
    - Keep `[AllowAnonymous]`

    **4. Add `Refresh` endpoint:**
    - `[HttpPost("refresh")]`, `[AllowAnonymous]` (refresh tokens are self-authenticating)
    - Accept `[FromBody] RefreshRequestDto request`
    - Call `authenticationService.RefreshAsync(request)`
    - Return Ok(result.Data) on success, Unauthorized on failure
    - Add ProducesResponseType attributes for 200 (RefreshResponseDto) and 401

    **5. Add `Revoke` endpoint:**
    - `[HttpPost("revoke")]`, `[AllowAnonymous]` (needs refresh token, not access token)
    - Accept `[FromBody] RevokeRequestDto request`
    - Call `authenticationService.RevokeAsync(request)`
    - Return Ok on success
    - Add ProducesResponseType for 200

    **6. Add `RevokeAll` endpoint:**
    - `[HttpPost("revoke-all")]`, `[Authorize]` (requires valid access token)
    - No request body — extract userId from `User.FindFirst(ClaimTypes.NameIdentifier)!.Value`
    - Parse to Guid, call `authenticationService.RevokeAllAsync(userId)`
    - Return Ok on success
    - Add using for `System.Security.Claims`

    **7. Add XML doc comments** to each endpoint for OpenAPI descriptions (following the pattern in research doc).

    **8. Create OpenAPI profile** for auth DTOs if needed — check if existing `OpenApiConfigurator` auto-discovers or if a profile is needed (look at GoalProfile pattern in `OrbitSpace/OpenApi/Profiles/`).
  </action>
  <verify>
    1. `dotnet build dotnet-web-api/` compiles.
    2. Start the API (`dotnet run --project dotnet-web-api/OrbitSpace`) and verify auth endpoints appear in Scalar docs at `https://localhost:5001/` (or whatever port is configured).
    3. Verify OpenAPI spec includes authentication endpoints: `curl -k https://localhost:7284/openapi/v1.json | grep -c "authentication"` should return > 0.
  </verify>
  <done>
    AuthenticationController has 5 endpoints (register, login, refresh, revoke, revoke-all) visible in OpenAPI. Login accepts JSON body DTO. Proper HTTP status codes and ProducesResponseType attributes. XML doc comments for API docs.
  </done>
</task>

<task type="auto">
  <name>Task 2: Fix ApplicationUserProvider to use real JWT claims</name>
  <files>
    dotnet-web-api/OrbitSpace/Identity/ApplicationUserProvider.cs
  </files>
  <action>
    **1. Remove the hardcoded temp user ID:**
    - Delete line: `private Guid TempUserId = new Guid("019c577c-c280-7036-a555-36746161bb89");`
    - Change `UserId` property from `=> TempUserId` to `=> Guid.Parse(GetValueFromClaim(ClaimTypes.NameIdentifier))`

    The `GetValueFromClaim` method already exists and correctly extracts claims from `_claims`. The `UserEmail` property already uses it. Only `UserId` is bypassed with the temp value.

    **Why this matters:** Without this fix, every authenticated request (goals, activities, todos) returns data for the hardcoded user ID instead of the logged-in user. This is the single most critical fix in the entire phase — it connects the JWT auth system to the actual application data.

    **Note:** The JWT token generated by `JwtTokenService` sets `ClaimTypes.Sub` (JwtRegisteredClaimNames.Sub) as the userId, but `ApplicationUserProvider` reads `ClaimTypes.NameIdentifier`. Verify these match. In .NET's JWT middleware, `JwtRegisteredClaimNames.Sub` maps to `ClaimTypes.NameIdentifier` by default via `JsonWebTokenHandler`, so this should work. If not, the JWT validation config in `AuthenticationConfig.cs` may need `MapInboundClaims = false` — check and adjust if needed.
  </action>
  <verify>
    1. `dotnet build dotnet-web-api/` compiles.
    2. Grep for "TempUserId" in the codebase — should return 0 results.
    3. Read the file and confirm UserId uses GetValueFromClaim.
  </verify>
  <done>
    ApplicationUserProvider reads real userId from JWT claims. No hardcoded temp ID exists. Sub claim from JWT maps correctly to ClaimTypes.NameIdentifier.
  </done>
</task>

</tasks>

<verification>
1. `dotnet build dotnet-web-api/` compiles without errors
2. No `[ApiExplorerSettings(IgnoreApi = true)]` on AuthenticationController
3. Login endpoint accepts `[FromBody] LoginRequestDto` (not separate string params)
4. Five auth endpoints exist: register, login, refresh, revoke, revoke-all
5. No "TempUserId" in codebase
6. ApplicationUserProvider.UserId reads from JWT claims
</verification>

<success_criteria>
Authentication controller exposes all endpoints via OpenAPI with proper DTOs and status codes. ApplicationUserProvider extracts real userId from JWT claims. The API can be tested via Scalar docs or Postman for the complete auth flow: register -> login -> refresh -> revoke.
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-authentication/01-02-SUMMARY.md`
</output>

---
phase: 01-foundation-authentication
plan: 04
type: execute
wave: 3
depends_on: ["01-03"]
files_modified:
  - next-js-app/proxy.ts
  - next-js-app/src/shared/lib/dal.ts
  - next-js-app/src/shared/lib/token-refresh.ts
  - next-js-app/app/api/(proxy)/[...path]/route.ts
  - next-js-app/src/shared/api/api-server-client.ts
  - next-js-app/src/app/providers/Providers.tsx
  - next-js-app/app/layout.tsx
  - next-js-app/package.json
autonomous: true

must_haves:
  truths:
    - "Unauthenticated users are redirected to /login when accessing protected routes"
    - "Authenticated users can access protected routes (dashboard, goals, etc.)"
    - "Server Components can fetch from .NET API using DAL with automatic auth header injection"
    - "Client Components can call proxy route which reads token from httpOnly cookie"
    - "Token refresh happens automatically when access token expires (with race condition prevention)"
    - "Clerk is completely removed from the codebase"
  artifacts:
    - path: "next-js-app/proxy.ts"
      provides: "Custom auth middleware replacing Clerk"
      contains: "access-token"
    - path: "next-js-app/src/shared/lib/dal.ts"
      provides: "Data Access Layer for Server Components"
      exports: ["getSession", "fetchFromApi"]
    - path: "next-js-app/src/shared/lib/token-refresh.ts"
      provides: "Client-side token refresh with race condition prevention"
      exports: ["handleTokenRefresh"]
    - path: "next-js-app/app/api/(proxy)/[...path]/route.ts"
      provides: "Proxy route using cookie-based auth instead of Clerk"
      contains: "access-token"
  key_links:
    - from: "next-js-app/proxy.ts"
      to: "cookies"
      via: "request.cookies.get('access-token')"
      pattern: "access-token"
    - from: "next-js-app/src/shared/lib/dal.ts"
      to: ".NET API"
      via: "fetchFromApi with Bearer token from cookie"
      pattern: "Authorization.*Bearer"
    - from: "next-js-app/app/api/(proxy)/[...path]/route.ts"
      to: "httpOnly cookies"
      via: "cookies().get('access-token')"
      pattern: "access-token"
    - from: "next-js-app/src/app/providers/Providers.tsx"
      to: "QueryClientProvider"
      via: "No ClerkProvider wrapping"
      pattern: "QueryClientProvider"
---

<objective>
Replace Clerk with custom auth infrastructure: custom middleware (proxy.ts), Data Access Layer for Server Components, token refresh queue for client-side, updated proxy route, and complete Clerk removal from all imports, providers, and dependencies.

Purpose: This connects everything together. Without middleware, protected routes are unguarded. Without DAL, Server Components can't fetch data securely. Without Clerk removal, the app has conflicting auth systems. This plan implements the defense-in-depth security model (middleware + DAL + per-request verification).
Output: Fully functional auth system with Clerk completely removed.
</objective>

<execution_context>
@C:/Users/Александр/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Александр/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/01-foundation-authentication/01-RESEARCH.md
@.planning/phases/01-foundation-authentication/01-03-SUMMARY.md
@.claude/rules/Next.js 16 + .NET API production-ready JWT architecture guide.md

Key existing files:
@next-js-app/proxy.ts
@next-js-app/src/shared/api/api-server-client.ts
@next-js-app/src/shared/api/api-client.ts
@next-js-app/app/api/(proxy)/[...path]/route.ts
@next-js-app/src/app/providers/Providers.tsx
@next-js-app/app/layout.tsx
@next-js-app/package.json
</context>

<tasks>

<task type="auto">
  <name>Task 1: Replace Clerk middleware, create DAL, update proxy route, create token refresh</name>
  <files>
    next-js-app/proxy.ts
    next-js-app/src/shared/lib/dal.ts
    next-js-app/src/shared/lib/token-refresh.ts
    next-js-app/app/api/(proxy)/[...path]/route.ts
    next-js-app/src/shared/api/api-server-client.ts
  </files>
  <action>
    **1. Replace proxy.ts** (currently Clerk middleware):
    - Remove all Clerk imports
    - Implement custom auth middleware:
      - Read `access-token` cookie from `request.cookies`
      - Read `refresh-token` cookie from `request.cookies`
      - Define public routes: `['/login', '/register', '/forgot-password']`
      - Also exclude API auth routes from protection: `/api/auth/*` must be public
      - If pathname matches public route → `NextResponse.next()`
      - If no access-token AND has refresh-token → redirect to `/api/auth/refresh?redirect={pathname}` (proactive refresh)
      - If no access-token AND no refresh-token → redirect to `/login?callbackUrl={pathname}`
      - If has access-token → `NextResponse.next()`
      - Export `config.matcher` that excludes: `_next/static`, `_next/image`, `favicon.ico`, and `api/auth` routes
      - Matcher pattern: `['/((?!api/auth|_next/static|_next/image|favicon.ico).*)']`

    **2. Create DAL** (`src/shared/lib/dal.ts`):
    - Import `cache` from 'react', `cookies` from 'next/headers', `redirect` from 'next/navigation'
    - `getSession`: wrapped in `cache()`, reads `access-token` from cookies, redirects to `/login` if missing, returns `{ token }`
    - `fetchFromApi<T>(endpoint: string, options?: RequestInit)`: calls getSession(), fetches from `${process.env.BACKEND_BASE_URL}${endpoint}` with Authorization Bearer header. On 401 → redirect('/login'). On !ok → throw Error. Returns parsed JSON as T.
    - **Why cache()**: React.cache() memoizes within a single render pass. If multiple Server Components call getSession() during one request, only one cookie read happens. This is NOT a cross-request cache.

    **3. Create token refresh queue** (`src/shared/lib/token-refresh.ts`):
    - `'use client'` directive (only used in browser)
    - Module-level variables: `isRefreshing = false`, `refreshQueue: Array<{resolve, reject}>`
    - `processQueue(error: Error | null)` helper: resolves/rejects all queued promises, clears queue
    - `handleTokenRefresh()`: if already refreshing, return new Promise added to queue. Otherwise set isRefreshing=true, fetch POST `/api/auth/refresh`. On success: processQueue(null). On failure: processQueue(error), redirect to `/login`. Finally: isRefreshing=false.
    - Export `handleTokenRefresh`

    **4. Update proxy route** (`app/api/(proxy)/[...path]/route.ts`):
    - Remove ALL Clerk imports (`import { auth } from '@clerk/nextjs/server'`)
    - Instead of `await auth()` and `getToken()`, read token from cookies: `const cookieStore = await cookies(); const token = cookieStore.get('access-token')?.value;`
    - Import `cookies` from `next/headers`
    - If no token → return 401 JSON response
    - Set `Authorization: Bearer ${token}` header
    - Keep the rest of the proxy logic (URL construction, method forwarding, body handling)
    - Keep using `backendBaseUrl` from `@/shared/config`

    **5. Update api-server-client.ts** (`src/shared/api/api-server-client.ts`):
    - Remove Clerk import (`import { auth } from '@clerk/nextjs/server'`)
    - Instead, import `cookies` from `next/headers`
    - Read token from `access-token` cookie
    - Create openapi-fetch client with `baseUrl: process.env.BACKEND_BASE_URL` (use server env var, not NEXT_PUBLIC_)
    - Set Authorization header from cookie token
    - Update the export to be `getServerApiClient` (keep same name)
    - Note: `backendBaseUrl` from shared/config uses `process.env.BACKEND_BASE_URL` already — verify this
  </action>
  <verify>
    1. No `@clerk` imports exist in any of the modified files: `grep -r "@clerk" next-js-app/proxy.ts next-js-app/src/shared/api/ next-js-app/app/api/`
    2. `proxy.ts` references `access-token` cookie
    3. `dal.ts` exports `getSession` and `fetchFromApi`
    4. Proxy route reads from cookies, not Clerk auth
    5. TypeScript compiles: `npx --prefix next-js-app tsc --noEmit`
  </verify>
  <done>
    Custom middleware protects routes using cookie-based auth. DAL provides defense-in-depth for Server Components. Token refresh queue prevents race conditions. Proxy route reads auth from httpOnly cookies. Server API client uses cookies instead of Clerk.
  </done>
</task>

<task type="auto">
  <name>Task 2: Complete Clerk removal from providers, layout, dependencies, and env</name>
  <files>
    next-js-app/src/app/providers/Providers.tsx
    next-js-app/app/layout.tsx
    next-js-app/package.json
  </files>
  <action>
    **1. Update Providers.tsx:**
    - Remove `import { ClerkProvider } from '@clerk/nextjs'`
    - Remove `<ClerkProvider>` wrapper — keep only `<QueryClientProvider>`
    - The component should just be QueryClientProvider + ReactQueryDevtools wrapping children
    - Keep `'use client'` directive

    **2. Search and remove ALL remaining Clerk references:**
    - Run grep across entire `next-js-app/` for `@clerk`, `clerk`, `ClerkProvider`, `useAuth` (from Clerk), `useUser` (from Clerk)
    - Check `app/layout.tsx` — if it imports anything from Clerk, remove it
    - Check any other files that might reference Clerk
    - Delete `next-js-app/.clerk/` directory if it exists
    - Remove Clerk env vars from `.env.local` if they exist (`NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY`, `CLERK_SECRET_KEY`). Keep `BACKEND_BASE_URL`.

    **3. Remove Clerk dependency:**
    - Remove `@clerk/nextjs` from `package.json` dependencies
    - Run `pnpm --prefix next-js-app install` to clean up node_modules
    - Verify no Clerk packages remain: `pnpm --prefix next-js-app ls @clerk/nextjs` should show nothing

    **4. Delete old shared schemas** (superseded by entity layer):
    - Delete `src/shared/schemas/loginSchema.ts`
    - Delete `src/shared/schemas/registerSchema.ts`
    - Check if anything imports from `@/shared/schemas/` — if so, update those imports to use `@/entities/auth`
    - If the `src/shared/schemas/` directory becomes empty, delete it

    **5. Update CLAUDE.md files** to reflect new auth system:
    - `next-js-app/CLAUDE.md`: Replace Clerk references with custom JWT auth description. Update environment variables section (remove Clerk keys, ensure BACKEND_BASE_URL is documented).
    - `dotnet-web-api/CLAUDE.md`: Update auth description if needed.
    - Keep changes minimal — just fix incorrect references.

    **6. Verify clean build:**
    - Run `pnpm --prefix next-js-app build` — must succeed
    - Check for any remaining `@clerk` imports: `grep -r "@clerk" next-js-app/src/ next-js-app/app/ next-js-app/proxy.ts` — must return empty
  </action>
  <verify>
    1. `grep -r "@clerk" next-js-app/src/ next-js-app/app/ next-js-app/proxy.ts` returns nothing.
    2. `grep -r "clerk" next-js-app/package.json` returns nothing.
    3. `pnpm --prefix next-js-app build` succeeds.
    4. `src/shared/schemas/loginSchema.ts` does not exist.
    5. `src/shared/schemas/registerSchema.ts` does not exist.
    6. `.clerk/` directory does not exist under `next-js-app/`.
  </verify>
  <done>
    Clerk completely removed from codebase: no imports, no provider, no dependencies, no env vars. Old shared schemas deleted (replaced by auth entity schemas). Build succeeds with zero Clerk references. CLAUDE.md files updated to reflect custom JWT auth.
  </done>
</task>

</tasks>

<verification>
1. Zero Clerk references in entire next-js-app codebase
2. `pnpm --prefix next-js-app build` succeeds
3. Middleware redirects unauthenticated users to /login
4. Middleware allows access to /login, /register, /forgot-password without auth
5. DAL exports getSession() and fetchFromApi()
6. Proxy route reads token from httpOnly cookie
7. Token refresh queue prevents concurrent refresh calls
8. No `@clerk/nextjs` in package.json
</verification>

<success_criteria>
Clerk is completely removed. Custom middleware protects routes. DAL provides defense-in-depth auth verification for Server Components. Proxy route uses cookie-based auth. Token refresh queue handles race conditions. The frontend builds successfully with the new auth system.
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-authentication/01-04-SUMMARY.md`
</output>

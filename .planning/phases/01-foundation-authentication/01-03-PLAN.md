---
phase: 01-foundation-authentication
plan: 03
type: execute
wave: 2
depends_on: ["01-01", "01-02"]
files_modified:
  - next-js-app/src/entities/auth/model/schemas.ts
  - next-js-app/src/entities/auth/model/types.ts
  - next-js-app/src/entities/auth/api/auth-query-keys.ts
  - next-js-app/src/entities/auth/model/use-auth.ts
  - next-js-app/src/entities/auth/index.ts
  - next-js-app/src/features/auth/login/ui/login-form.tsx
  - next-js-app/src/features/auth/login/index.ts
  - next-js-app/src/features/auth/register/ui/register-form.tsx
  - next-js-app/src/features/auth/register/index.ts
  - next-js-app/app/(auth)/layout.tsx
  - next-js-app/app/(auth)/login/page.tsx
  - next-js-app/app/(auth)/register/page.tsx
  - next-js-app/app/(auth)/forgot-password/page.tsx
  - next-js-app/app/api/auth/login/route.ts
  - next-js-app/app/api/auth/register/route.ts
  - next-js-app/app/api/auth/refresh/route.ts
  - next-js-app/app/api/auth/logout/route.ts
  - next-js-app/app/api/auth/session/route.ts
autonomous: true

must_haves:
  truths:
    - "User can see a login page at /login with email, password, remember me fields"
    - "User can see a register page at /register with email, password, name, date of birth fields"
    - "Login form submits to /api/auth/login which forwards to .NET and sets httpOnly cookies"
    - "Register form submits to /api/auth/register, then auto-logs in"
    - "Forgot password page shows a 'Coming soon' stub"
    - "Auth pages have centered card layout with OrbitSpace branding"
  artifacts:
    - path: "next-js-app/app/(auth)/login/page.tsx"
      provides: "Login page with form"
      contains: "LoginForm"
    - path: "next-js-app/app/(auth)/register/page.tsx"
      provides: "Register page with form"
      contains: "RegisterForm"
    - path: "next-js-app/app/api/auth/login/route.ts"
      provides: "Login route handler that sets httpOnly cookies"
      exports: ["POST"]
    - path: "next-js-app/app/api/auth/register/route.ts"
      provides: "Register route handler"
      exports: ["POST"]
    - path: "next-js-app/app/api/auth/refresh/route.ts"
      provides: "Token refresh route handler"
      exports: ["POST"]
    - path: "next-js-app/src/entities/auth/model/schemas.ts"
      provides: "Zod validation schemas for login and register"
      contains: "loginSchema"
  key_links:
    - from: "next-js-app/src/features/auth/login/ui/login-form.tsx"
      to: "/api/auth/login"
      via: "fetch POST"
      pattern: "fetch.*api/auth/login"
    - from: "next-js-app/app/api/auth/login/route.ts"
      to: ".NET /api/authentication/login"
      via: "server-to-server fetch with BACKEND_BASE_URL"
      pattern: "BACKEND_BASE_URL.*authentication/login"
    - from: "next-js-app/app/api/auth/login/route.ts"
      to: "httpOnly cookies"
      via: "cookies().set with httpOnly: true"
      pattern: "httpOnly.*true"
---

<objective>
Create the complete frontend auth layer: entity (schemas, types, hooks), feature (login/register forms), pages (auth layout, login, register, forgot-password stub), and API route handlers (login, register, refresh, logout, session) that implement the BFF proxy pattern with httpOnly cookies.

Purpose: Users need to actually see login/register pages, submit credentials, and have tokens stored securely in httpOnly cookies. This is the user-facing side of authentication.
Output: Functional auth pages and route handlers. User can navigate to /login, fill the form, and the request flows through to .NET backend.
</objective>

<execution_context>
@C:/Users/Александр/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Александр/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/01-foundation-authentication/01-RESEARCH.md
@.planning/phases/01-foundation-authentication/01-01-SUMMARY.md
@.planning/phases/01-foundation-authentication/01-02-SUMMARY.md
@.claude/rules/Next.js 16 + .NET API production-ready JWT architecture guide.md

Key existing files:
@next-js-app/src/shared/schemas/loginSchema.ts (existing, will be superseded)
@next-js-app/src/shared/schemas/registerSchema.ts (existing, will be superseded)
@next-js-app/src/shared/config/backend.ts
@next-js-app/src/app/providers/Providers.tsx
@next-js-app/app/layout.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create auth entity layer (schemas, types, hooks, query keys)</name>
  <files>
    next-js-app/src/entities/auth/model/schemas.ts
    next-js-app/src/entities/auth/model/types.ts
    next-js-app/src/entities/auth/api/auth-query-keys.ts
    next-js-app/src/entities/auth/model/use-auth.ts
    next-js-app/src/entities/auth/index.ts
  </files>
  <action>
    **1. Create `src/entities/auth/model/schemas.ts`:**
    - `loginSchema`: z.object with email (z.string().email()), password (z.string().min(4)), rememberMe (z.boolean().default(false))
    - `registerSchema`: z.object with email (z.string().email()), password (z.string().min(4)), repeatPassword (z.string()), firstName (z.string().min(1).max(50)), lastName (z.string().min(1).max(50)), dateOfBirth (z.coerce.date() with refine for minimum age 13)
    - Add .refine on registerSchema for password match (path: ['repeatPassword'])
    - Export inferred types: `LoginInput`, `RegisterInput`
    - Use Zod v4 syntax (already in package.json as ^4.1.13)

    **2. Create `src/entities/auth/model/types.ts`:**
    - `AuthUser` type: id (string), email (string), firstName (string), lastName (string), dateOfBirth (string), emailVerified (boolean)
    - `AuthResponse` type: user (AuthUser)
    - `AuthError` type: error (string), fieldErrors? (Record<string, string[]>)

    **3. Create `src/entities/auth/api/auth-query-keys.ts`:**
    - Follow existing query key factory pattern (see goal query keys for reference)
    - `authQueryKeys.session: () => ['auth', 'session'] as const`

    **4. Create `src/entities/auth/model/use-auth.ts`:**
    - `'use client'` directive
    - Use `useQuery` from @tanstack/react-query
    - queryKey: `authQueryKeys.session()`
    - queryFn: fetch `/api/auth/session`, return json if ok, return null if !ok
    - staleTime: 5 * 60 * 1000 (5 minutes)
    - retry: false (don't retry auth checks)
    - Return `{ user, isAuthenticated: !!user, isLoading }`

    **5. Create `src/entities/auth/index.ts`:**
    - Export schemas: `loginSchema`, `registerSchema`, `LoginInput`, `RegisterInput`
    - Export types: `AuthUser`, `AuthResponse`, `AuthError`
    - Export hook: `useAuth`
    - Export query keys: `authQueryKeys`
  </action>
  <verify>
    Check that file `next-js-app/src/entities/auth/index.ts` exists and exports all expected symbols. Run `pnpm --prefix next-js-app build` or at minimum `npx --prefix next-js-app tsc --noEmit` to verify TypeScript compilation.
  </verify>
  <done>
    Auth entity layer follows FSD pattern with Zod schemas (min 4 char password per user decision), TypeScript types, query key factory, and useAuth hook. All exported from index.ts barrel file.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create auth pages, forms, and API route handlers</name>
  <files>
    next-js-app/src/features/auth/login/ui/login-form.tsx
    next-js-app/src/features/auth/login/index.ts
    next-js-app/src/features/auth/register/ui/register-form.tsx
    next-js-app/src/features/auth/register/index.ts
    next-js-app/app/(auth)/layout.tsx
    next-js-app/app/(auth)/login/page.tsx
    next-js-app/app/(auth)/register/page.tsx
    next-js-app/app/(auth)/forgot-password/page.tsx
    next-js-app/app/api/auth/login/route.ts
    next-js-app/app/api/auth/register/route.ts
    next-js-app/app/api/auth/refresh/route.ts
    next-js-app/app/api/auth/logout/route.ts
    next-js-app/app/api/auth/session/route.ts
  </files>
  <action>
    **1. Create LoginForm** (`src/features/auth/login/ui/login-form.tsx`):
    - `'use client'` directive
    - Use `useForm` from react-hook-form with zodResolver(loginSchema)
    - Fields: email (Input type="email"), password (Input type="password"), rememberMe (Checkbox from shadcn/ui)
    - Use `useTransition` for pending state
    - On submit: fetch POST `/api/auth/login` with JSON body
    - On success: extract `callbackUrl` from `window.location.search`, `router.push(callbackUrl ?? '/')`, then `router.refresh()`
    - On error: show generic error message from response
    - Use shadcn/ui components: `Input`, `Button`, `Label`, `Checkbox` — check which exist in `src/shared/ui/` and use them
    - Loading state: button disabled with "Signing in..." text during transition
    - Export from `src/features/auth/login/index.ts`

    **2. Create RegisterForm** (`src/features/auth/register/ui/register-form.tsx`):
    - `'use client'` directive
    - Use `useForm` with zodResolver(registerSchema)
    - Fields: firstName, lastName, email, dateOfBirth (date input or DatePicker if available), password, repeatPassword
    - On submit: fetch POST `/api/auth/register`
    - On success (register returns success): auto-login by calling `/api/auth/login` with email + password, then redirect to `/`
    - On error: show error message
    - Use shadcn/ui components
    - Export from `src/features/auth/register/index.ts`

    **3. Create auth layout** (`app/(auth)/layout.tsx`):
    - NOT a `'use client'` component — this is a Server Component layout
    - Centered flex layout: `min-h-screen flex items-center justify-center bg-background`
    - Card container: `w-full max-w-md`
    - Header: OrbitSpace name displayed above card (use `<h1>` with font-poppins)
    - Card wrapper: `bg-card border rounded-lg p-8 shadow-sm`
    - This layout group `(auth)` does NOT use DashboardLayout (sidebar/nav), it's a standalone layout
    - **IMPORTANT**: The root layout.tsx currently wraps everything in DashboardLayout. The auth pages should NOT have the dashboard sidebar. Create this as a route group with its own layout. The `(auth)` route group will need its own root-level layout segment OR the root layout needs to be modified to conditionally show DashboardLayout. The simplest approach: move DashboardLayout from root layout into a route group like `(dashboard)` — but that's a larger change. For now, create the `(auth)` layout in `app/(auth)/layout.tsx` and it will automatically not inherit the DashboardLayout if the root layout is adjusted.
    - **Resolution**: Check if there's already a `(dashboard)` route group. If root layout unconditionally wraps children in DashboardLayout, you may need to update root layout to NOT wrap in DashboardLayout, and instead have `(dashboard)/layout.tsx` provide it. This is necessary — auth pages must not show the app's sidebar/nav.

    **4. Create login page** (`app/(auth)/login/page.tsx`):
    - Server Component (no 'use client')
    - Heading: "Welcome back" / "Sign in to your account"
    - Render `<LoginForm />`
    - "Forgot your password?" link → `/forgot-password`
    - "Don't have an account? Sign up" link → `/register`

    **5. Create register page** (`app/(auth)/register/page.tsx`):
    - Server Component
    - Heading: "Create your account" / "Start your OrbitSpace journey"
    - Render `<RegisterForm />`
    - "Already have an account? Sign in" link → `/login`

    **6. Create forgot-password stub** (`app/(auth)/forgot-password/page.tsx`):
    - Simple page with "Coming soon" message per user decision (deferred)
    - Link back to `/login`

    **7. Create login route handler** (`app/api/auth/login/route.ts`):
    - Parse and validate body with `loginSchema`
    - Forward to `.NET API: `${process.env.BACKEND_BASE_URL}/api/authentication/login`
    - Send: `{ email, password, rememberMe, deviceInfo: null }` (deviceInfo from User-Agent header if desired)
    - On success from .NET (returns `{ accessToken, refreshToken, user }`):
      - Set `access-token` httpOnly cookie: httpOnly=true, secure=(NODE_ENV==='production'), sameSite='lax', maxAge=60*15 (15min), path='/'
      - Set `refresh-token` httpOnly cookie: same settings but maxAge = rememberMe ? 60*60*24*30 (30 days) : undefined (session cookie)
      - Return `{ user }` only (never return raw tokens to browser)
    - On error: return `{ error: message }` with appropriate status

    **8. Create register route handler** (`app/api/auth/register/route.ts`):
    - Parse body, validate with registerSchema (server-side validation)
    - Forward to .NET: `${process.env.BACKEND_BASE_URL}/api/authentication/register`
    - Send: `{ email, password, firstName, lastName, dateOfBirth: dateOfBirth.toISOString() }`
    - On success: return `{ success: true }`
    - On error: return `{ error: message }` with status from backend

    **9. Create refresh route handler** (`app/api/auth/refresh/route.ts`):
    - Read `refresh-token` from cookies
    - If missing, return 401
    - Forward to .NET: `${process.env.BACKEND_BASE_URL}/api/authentication/refresh` with `{ refreshToken }`
    - On success: update both cookies with new tokens (same settings as login)
    - On failure: delete both cookies, return 401
    - **Note on maxAge preservation**: When refreshing, we don't know the original "remember me" setting. Use the presence of the refresh-token cookie's existence (session cookies won't survive browser restart, persistent cookies will). For the new refresh cookie, use the same maxAge strategy: 30 days if the request came from a non-expired cookie (meaning it was persistent), session otherwise. Simplification: always set 30 days on refresh — the backend controls the real expiration via the DB record.

    **10. Create logout route handler** (`app/api/auth/logout/route.ts`):
    - Read `refresh-token` from cookies
    - If present, forward to .NET: `${process.env.BACKEND_BASE_URL}/api/authentication/revoke` with `{ refreshToken }`
    - Ignore backend errors (best-effort revocation)
    - Delete both cookies (`access-token`, `refresh-token`)
    - Return `{ success: true }`

    **11. Create session route handler** (`app/api/auth/session/route.ts`):
    - Read `access-token` from cookies
    - If missing, return `{ user: null }` with status 401
    - Decode the JWT on Next.js side to extract user claims (sub, email) — use `jose` library or just decode the base64 payload without verification (the .NET API will verify on actual data requests)
    - Return `{ user: { id, email } }` from JWT claims
    - **Alternative simpler approach**: Forward to a /api/users/me endpoint on .NET if it exists. Check if IUserService has a GetByIdAsync or similar. If not, just decode the JWT payload client-side for basic user info.
  </action>
  <verify>
    1. Files exist at all specified paths.
    2. `pnpm --prefix next-js-app build` compiles (or at least `npx --prefix next-js-app tsc --noEmit`).
    3. Navigate to `http://localhost:3000/login` — login page renders with form.
    4. Navigate to `http://localhost:3000/register` — register page renders with form.
    5. Navigate to `http://localhost:3000/forgot-password` — shows "Coming soon" stub.
    6. Auth pages do NOT show dashboard sidebar/nav.
  </verify>
  <done>
    Login and register pages render at /login and /register with centered card layout, OrbitSpace branding, proper form fields per user decisions. Forgot-password stub exists. All 5 API route handlers created (login, register, refresh, logout, session). Login route stores tokens in httpOnly cookies and returns only user data to browser. Register route auto-logs in after successful registration. Auth pages do not show dashboard navigation.
  </done>
</task>

</tasks>

<verification>
1. Auth entity layer complete with schemas, types, hook, query keys
2. Login form has email, password, remember me fields with Zod validation
3. Register form has all required fields including date of birth
4. Auth layout is centered card without dashboard nav
5. All 5 API route handlers exist and use BACKEND_BASE_URL
6. Login route handler sets httpOnly cookies (never returns raw tokens)
7. Refresh route handler reads from cookies and updates them
8. Logout route handler revokes token on backend and clears cookies
</verification>

<success_criteria>
User can see login and register pages with proper form validation. Forms submit to Next.js API routes which proxy to .NET backend. Login sets httpOnly cookies. Register auto-logs in. Auth pages have clean centered layout without dashboard chrome. Forgot-password shows stub page.
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-authentication/01-03-SUMMARY.md`
</output>
